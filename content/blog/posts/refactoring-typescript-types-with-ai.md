---
slug: "refactoring-typescript-types-with-ai"
title: "AIと共に育てるコードベース：散らばった型定義をリファクタリングした実践記録"
publishedAt: "2025-11-15"
summary: "AIに任せきりで散らばったTypeScriptの型定義。そのカオスを、AIと対話しながら『分析→設計→実行』のワークフローで安全に整理していく過程を全記録。単なるコード整理に留まらない、AIとの協調開発の実践例です。"
author: "ClaudeMix Team"
tags: ["refactoring", "architecture"]
category: "Claude Best Practices"
description: "AIに任せきりで散らばったTypeScriptの型定義。そのカオスを、AIと対話しながら『分析→設計→実行』のワークフローで安全に整理していく過程を全記録。単なるコード整理に留まらない、AIとの協調開発の実践例です。"
---

## はじめに

### AI開発でこんなことありませんか？

AIに任せきりで高速開発を進めた。
しかし、型定義に関する設計指示を怠ったために、`interface`や`type`が無秩序に各ファイルへ散らばってしまい、保守性が低下してしまった。
なんとかコードレビューで指摘されたが、どこから手をつければ良いか分からず、技術的負債が蓄積されてしまった。

### この記事をお勧めしない人

- AIに任せきりで、設計の主導権を人間が握る必要性を感じていない人。
- 型定義が散らばっていても、動けばそれで十分だと考える人。
- リファクタリング（※既存のコードの動作を変えずに、内部構造を改善する作業）の価値を、全く理解していない人。

もし一つでも当てはまらないなら、読み進める価値があるかもしれません。

### このままでは危険です

型定義の設計を放置することで、あなたのコードベースには「見えない技術的負債」が静かに蓄積されていきます。
やがて、新しい機能を追加する際に「どの型を使えば良いのか」判断できず、開発速度が著しく低下するでしょう。
ついに、チームメンバーは重複した型定義に混乱し、バグが頻発し、あなたのプロジェクトは「保守不可能なレガシーコード」と化すかもしれません。

### こんな未来が手に入ります

この記事を読めば、AIと対話しながら「分析→設計→実行」のワークフローで型定義を安全に整理する手法が手に入ります。
具体的には、AIを「全自動の魔法の杖」ではなく「極めて優秀な専門家アシスタント」として扱い、人間が設計の主導権を握りながら協調作業を進める**設計図**を手に入れられます。
この方法は、机上の空論ではありません。まさに**このブログ自身のリファクタリングプロセスとして実証済み**です。
この情報は、単なる「型定義をまとめる」という表層的なテクニックではなく、AIとの協調開発の本質を理解した**未来の開発現場から得られた一次情報**です。

### 私も同じでした

筆者も過去に同じ技術的負債で悩み抜き、このブログを「AIとの協調開発」で作り上げる過程でこの手法を確立しました。
この記事で、あなたのコードベースの保守性を向上させる基本的な考え方と、明日から試せるAIとの対話パターンを持ち帰れるように書きました。
さらに深掘りして、TypeScriptの型設計のベストプラクティスを知りたい方は、その詳細な実装方法を確認できます。

## 📝 概要

AIエージェントにコーディングを任せ、高速で開発を進めていました。しかし、ある問題が発覚します。それは、**型定義に関する設計指示を怠ったために、`interface`や`type`が無秩序に各ファイルへ散らばってしまった**ことです。

これは、AIコーディングを実践する多くの開発者が陥りがちな「見過ごされた技術的負債」ではないでしょうか。AIは指示通りにコードを生成しますが、プロジェクト全体の整合性や将来のメンテナンス性までを考慮した「設計」は、人間が主導権を握る必要があります。

この記事では、この「AI開発によって生じた型定義のカオス」という問題を、AIコーディングアシスタント（Gemini Code Assist）と協力して解決していくリファクタリングの全プロセスを記録します。

目指すのは、単なるコード整理ではありません。**AIを「全自動の魔法の杖」ではなく「極めて優秀な専門家アシスタント」として扱い、人間が設計の主導権を握りながら協調作業を進める**という、次世代の開発スタイルを実践することです。

## ⚠️ 問題の発見と症状

開発を進める中で、以下のような症状が顕在化してきました。

- **重複した型定義**: `TagGroup` という全く同じインターフェースが、3つの異なるコンポーネントファイルに存在していた。
- **関心の散在**: ブログ記事に関連する型 (`Post`, `PostSummary`, `BlogPost`) が、データアクセス層や自動生成ファイルなど、複数の場所に点在していた。
- **見通しの悪さ**: 新しい機能を追加する際、どの型を使えば良いのか、あるいは新しい型をどこに定義すべきか判断するのに時間がかかる。

これは、コードベースの健全性を損ない、将来の開発速度を低下させる明確なサインです。

## 🔍 調査と方針決定：AIとの対話

この問題を解決するため、AIアシスタントに相談を持ちかけました。

🧑‍💻: 「散らばったTypeScriptの型定義を一つのファイルにまとめたい。関連ファイルを全部開けば良い？」

🤖: 「はい、関連ファイルをすべて開くのは非常に効果的です。開かれているファイル全体をコンテキストとして読み込み、横断的に型定義とその利用箇所を把握できます。」

単純に「全部まとめて」と指示することもできましたが、それでは保守性の低い巨大な「神ファイル」が生まれるリスクがあります。そこで、さらに議論を深めました。

🧑‍💻: 「一つのファイルに集約して循環参照などで壊れる懸念はある？」

🤖: 「良い視点です。最も注意すべきは**循環参照**です。対策として `import type` を徹底することが重要です。また、すべてを一つにまとめるのではなく、**ドメインごと（User関連、Product関連など）にファイルを分割する**のがおすすめです。」

この対話を通じて、私たちは闇雲にリファクタリングするのではなく、明確な戦略を持って進めることにしました。

### 決定したワークフロー

AIとの議論の末、以下の**「分析 → 設計(人間) → 実行」**という、人間が主導権を握るワークフローを採用しました。

1. **分析**: AIに重複・関連する型をリストアップさせ、現状を客観的に把握する。
2. **設計**: AIの分析結果を元に、どの型をどこに集約するか、あるいは集約しないかを人間が判断・設計する。
3. **実行**: 人間が決定した設計に基づき、具体的なコードの書き換え作業をAIに指示する。

## 🔧 実装フェーズ：最初のステップ

ワークフローに従い、まずは最も分かりやすい問題から着手します。

### ステップ1: 関連ファイルの特定と一括オープン

まず、AIにプロジェクト内の型定義をリストアップさせ、そのファイルパス一覧を作成しました。

次に、ターミナルからVS Codeのコマンドを使い、リストアップされた数十のファイルを手作業ではなく一括で開きます。

```bash
# bash用のコマンド（PowerShellとは構文が違う点に注意）
# -r オプションで「既存のウィンドウで開く」のがポイント
code -r $(cat 'path/to/型リスト.txt' | grep '^app\\.*:' | cut -d':' -f1 | sort -u)
```

この時点で、シェルの違い（bash vs PowerShell）や、コマンドのオプション（`-r`）といった細かい部分で躓きましたが、これもAIと対話しながら解決しました。

### ステップ2: AIによる分析

関連ファイルをすべて開いた状態で、AIに分析を依頼しました。

🧑‍💻: 「開いているファイルを確認して」

🤖: 「承知いたしました。分析の結果、`TagGroup` というインターフェースが3つのファイルで完全に重複しています。これは集約の最有力候補です。」

### ステップ3: 人間による設計とAIへの実行指示

AIの分析は妥当でした。まずはこの `TagGroup` の集約から始めることにします。集約先として、ブログ関連の仕様をまとめる `app/specs/blog/types.ts` を指定しました。

🧑‍💻: 「`TagGroup` を `app/specs/blog/types.ts` に集約して」

🤖: 「承知いたしました。」

この指示に基づき、AIは以下の3つの変更を提案・実行しました。

1. **集約**: `app/specs/blog/types.ts` に `TagGroup` を定義し、`export`する。
2. **削除**: 元の3つのファイルから `TagGroup` の定義を削除する。
3. **更新**: `import type { TagGroup } from '~/specs/blog/types';` のように、`import`文を更新する。

結果、重複が解消され、`TagGroup` の定義は一箇所に集約されました。これで、将来の仕様変更にも強く、見通しの良いコードベースへの第一歩を踏み出すことができました。

## 今回の学びと感想

今回のリファクタリングを通じて、以下の重要な学びを得ました。

### AIとの協調開発の本質

AIは「全自動の魔法の杖」ではなく「極めて優秀な専門家アシスタント」として扱うべきです。人間が設計の主導権を握り、AIに分析と実行を任せるというワークフローが、最も効果的でした。

### 「分析 → 設計 → 実行」のワークフロー

1. **分析**: AIに重複・関連する型をリストアップさせ、現状を客観的に把握する
2. **設計**: AIの分析結果を元に、どの型をどこに集約するか、人間が判断・設計する
3. **実行**: 人間が決定した設計に基づき、具体的なコードの書き換え作業をAIに指示する

このワークフローにより、保守性の低い「神ファイル」を作ることなく、適切な粒度で型定義を整理できました。

同じような課題で悩んだ方はいませんか？
もっと良い解決方法があれば教えてください！

---

### このシリーズの記事

- **Part 1**: [単純な重複の排除](/blog/refactoring-typescript-types-with-ai)
- **Part 2**: [『唯一の真実の源』の確立](/blog/refactoring-typescript-types-single-source-of-truth)
- **Part 3**: [『関心の分離』の実践](/blog/refactoring-typescript-types-separation-of-concerns)
- **Part 4**: [ドメイン知識の集約](/blog/refactoring-typescript-types-domain-knowledge)
- **Part 5**: [『生きた仕様書の完成』](/blog/refactoring-typescript-types-summary)
