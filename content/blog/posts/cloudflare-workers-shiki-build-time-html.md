---
slug: "cloudflare-workers-shiki-build-time-html"
title: "Cloudflare WorkersのWebAssembly制約をビルド時HTML変換で乗り越える"
description: "Cloudflare Workers環境でShikiのWebAssemblyが動作せず、ブログ記事詳細ページがエラーになる問題に遭遇。ビルド時にマークダウンをHTMLに変換する戦略と、並列処理の競合を防ぐShiki事前初期化の実装を解説します。"
author: "ClaudeMix Team"
publishedAt: "2025-12-02"
category: "ClaudeMix 記録"
tags: ["Pages", "troubleshooting", "Vite"]
freeContentHeading: "⚠️ 問題の発見と症状"
---

## はじめに

### Cloudflare Workersへのデプロイでこんなことありませんか？

ローカル環境では完璧に動くブログ。特に、コードブロックのシンタックスハイライト（色付け表示）も綺麗に表示されて満足していた。
しかし、いざCloudflare Pagesにデプロイしてみると、記事ページだけが「Application Error」で真っ白に。ログには `WebAssembly.instantiate(): Wasm code generation disallowed` という謎のエラーが…。
とりあえずシンタックスハイライトを無効にしたら動いたけど、技術ブログとして致命的だし、根本的な解決にはなっていない。

### この記事をお勧めしない人

- ローカル環境と本番環境の違いなんて、その場でググって解決すればいいと思っている人。
- シンタックスハイライトのためだけにビルドプロセスを複雑にするなんて、馬鹿げていると考える人。
- サーバーレス環境の制約は、単なる技術選定のミスであり、アーキテクチャで乗り越える課題ではないと考える人。

もし一つでも当てはまらないなら、読み進める価値があるかもしれません。

### 静かに埋め込まれる「環境依存の地雷」

- その場しのぎの修正を続けることで、コードベースには「環境依存の地雷」が静かに埋め込まれていく。特にAIは、このエラーに遭遇すると「ライブラリを別のものに交換する」という無限試行を繰り返し、本質的な解決（実行タイミングの見直し）に到達できない。
- 新しいライブラリを導入した途端、別のWASM関連エラーが再発してデプロイが失敗し、AIは再び同じループに陥って開発者の時間を奪い続ける。
- 本番環境の制約に怯え、新しい技術の導入をためらうようになり、プロダクトは時代遅れの技術スタックに取り残されてしまう。

### こんな未来が手に入ります

- この記事を読めば、Cloudflare Workersの制約を逆手に取り、パフォーマンスを向上させる設計思想が手に入ります。
- 具体的には、重い処理をビルド時に完了させる「事前生成」というアプローチで、サーバーレス環境の制約を回避しつつ、高速な表示を実現する**アーキテクチャ設計の思考法**を手に入れられます。
- この方法は、机上の空論ではありません。まさに**このブログ自身のシンタックスハイライト機能として実証済み**です。21記事を数秒で変換し、本番環境でのエラーをゼロにしました。
- この情報は、単なるエラー解決策ではなく、**AIが陥るライブラリ交換ループから脱出し、実行環境の制約を「最適化の機会」に変える**意思決定プロセスという、AIコーダーにとって他では得られない一次情報です。

### 私も同じでした

筆者も過去に同じWASMエラーで悩み抜き、最初はAIが提案する「別のシンタックスハイライトライブラリに交換する」という試行を繰り返しました。しかし、すべて同じエラーに行き着きました。
このブログを「AIによる実装」と「人間による設計・統制」で作り上げる過程で、**AIが提案しないアプローチ（実行タイミングの見直し）**という解決策を見つけました。
この記事で、サーバーレス環境の制約を理解し、安定したデプロイを実現するための基本的な考え方と、AIを制御する意思決定の基準を持ち帰れるように書きました。
さらに深掘りして、ビルドプロセスを最適化する具体的なアーキテクチャ設計と、並列処理の競合を乗り越えた実装の詳細を知りたい方は、その技術的手順とパフォーマンス測定結果を確認できます。

## 📝 概要

Cloudflare Pages（Workers環境）にデプロイしたRemixブログで、記事詳細ページを開くと「Application Error!」が表示される問題に遭遇しました。
ローカル開発環境では正常に動作していたため、サーバーレス環境特有の制約が原因でした。

**この記事で得られるもの:**

- ✅ **実行環境による演算拒否**への対処法（ランタイム vs ビルド時の主権委譲）
- ✅ **AIがループする根本原因**の理解（なぜライブラリ交換では解決しないのか）
- ✅ **21記事を数秒で変換し、エラーをゼロにした**実証済みのアーキテクチャ

AIは「別のライブラリを試しましょう」と提案し続けます。しかし、それは根本治療ではなく対症療法です。
根本原因はライブラリではなく、**Cloudflare Workersという実行環境の『思想』**にありました。

ここから先は、AIが絶対に提案しない**『実行タイミングの主権委譲』**という解決策の全貌と、
具体的な実装コード、並列処理の競合を乗り越えた技術的手順、そして実際のパフォーマンス測定結果を、すべて公開します。

## ⚠️ 問題の発見と症状

stg環境（テスト用の公開環境）にデプロイ後、記事一覧ページは表示されるものの、記事詳細ページ（例: `/blog/welcome`）を開くと「Application Error!」と表示されてしまいました。

**エラーメッセージ:**

~~~text
CompileError: WebAssembly.instantiate(): Wasm code generation disallowed by embedder
~~~

**症状:**

- ✅ ホーム画面: 正常表示
- ✅ ブログ一覧ページ: 正常表示
- ❌ 記事詳細ページ: Application Error
- ローカル開発環境では再現せず、デプロイ後にのみ発生

## 🔍 調査と試行錯誤のプロセス

### 仮説1: Cloudflare Workersの制約が原因ではないか？

まず、Cloudflare Workers環境の制約を確認しました。公式ドキュメントによると、**動的なWebAssembly（※）生成は許可されていない**ことが判明。シンタックスハイライトライブラリはコードの色付けのために内部でWebAssembly（正規表現エンジン）を使っているため、これが原因でエラーになっている可能性が高いと推測しました。

**判明した事実:**

- Cloudflare Workersは事前コンパイルされたWASMのみサポート
- ランタイムでの動的WASM生成は禁止
- シンタックスハイライトライブラリは初期化時に動的にWASMを生成

> ※ **WebAssembly (WASM)**: ウェブブラウザで高速に動くプログラムの形式。

### 仮説2: ブラウザ側での変換を試す

次に、サーバー側での処理を諦め、マークダウンをそのままブラウザに送り、ユーザーの画面でHTMLに変換する方法を検討しました。しかし、この方法には以下の問題がありました。

**問題点:**

- 初回表示が遅くなる（クライアント側で毎回変換）
- SEO的に不利（HTMLが初期状態では存在しない）
- ユーザー体験の低下

この方法はデメリットが大きいため、最終手段として保留しました。

### 仮説3: ビルド時にHTML変換するアプローチ

最終的に、「ビルド時にあらかじめマークダウンをHTMLに変換しておけば、サーバー（Workers環境）では完成したHTMLを配信するだけで済む」というアプローチに行き着きました。

**メリット:**

- Workers環境でWASMを使用しない
- 高速な初期表示（HTML配信のみ）
- SEO最適化
- ビルド時の通常環境ではシンタックスハイライトライブラリが正常動作

## 💡 根本原因の特定

調査の結果、根本原因は以下の3つの組み合わせでした。

1. **Workers環境のWASM制約**: Cloudflare Workersはセキュリティとパフォーマンスのため、動的なWebAssembly生成を禁止している。
2. **シンタックスハイライトライブラリの依存関係**: 色付けライブラリは内部でWebAssembly実装の正規表現エンジンに依存している。
3. **ランタイム変換の試み**: アプリケーションが、ユーザーからのリクエスト時に（ランタイムで）マークダウンからHTMLへの変換を実行しようとしていた。

**問題の本質:**
サーバーレス環境の制約に対して、**処理の実行タイミング（ランタイム vs ビルド時）**を見直す必要があったのです。

では、この問題をどう解決したのか。具体的な実装アプローチと、並列処理で遭遇した競合問題をどう乗り越えたか。その詳細な技術的手順と、実際のパフォーマンス測定結果を公開します。

## 🔧 解決策

### プレビルドスクリプトの実装

`scripts/prebuild/generate-blog-posts.js` に、ビルド時にMarkdownをHTMLに変換するロジックを追加しました。

~~~javascript
import { marked } from 'marked';
import sanitizeHtml from 'sanitize-html';
import { createHighlighter } from 'shiki/bundle/full';

// Shikiハイライターをシングルトン（※）で管理
let highlighter = null;

async function getHighlighter() {
  if (!highlighter) {
    console.log('⚡ Initializing Shiki highlighter...');
    highlighter = await createHighlighter({
      themes: ['github-dark'],
      langs: ['javascript', 'typescript', 'html', 'css', 'markdown', 'bash', 'json', 'tsx', 'diff', 'yaml', 'xml'],
    });
  }
  return highlighter;
}

async function convertMarkdownToHtml(markdown) {
  const hl = await getHighlighter();
  // ...（markedとShikiを連携させてHTMLに変換する処理）...
  const rawHtml = await marked.parse(markdown);
  return sanitizeHtml(rawHtml, { /* サニタイズ設定 */ });
}
~~~

> ※ **シングルトン**: プログラム全体でインスタンス（実体）が1つしか作られないことを保証するデザインパターン。

#### 並列処理の最適化

**ぶつかった壁:** 21記事を並列処理（`Promise.all`）すると、複数の処理が同時に`getHighlighter()`を呼び出してしまい、リソースの競合が起きてハングアップしました。

**解決方法:** 並列処理を開始する前に、一度だけShikiの初期化処理を呼び出すように修正しました。

~~~diff
async function generateBlogPosts() {
  try {
    console.log('🚀 Starting blog posts generation...');
+
+   // 並列処理前にShikiを初期化（競合防止）
+   await getHighlighter();

    // Markdownファイルを読み込む
    const posts = await Promise.all(
      markdownFiles.map(async (file) => {
        // HTML変換処理（既に初期化済みのhighlighterを使用）
        const htmlContent = await convertMarkdownToHtml(content);
        return { slug, content: htmlContent, ... };
      })
    );
~~~

**効果:**

- ✅ ハング問題を完全解決
- ✅ 並列処理の高速性を維持
- ✅ シングルトンパターンで1つのインスタンスのみ生成されることを保証

## 🎓 学んだこと・まとめ

### 技術的な学び

- **実行環境の制約を理解する**: Cloudflare Workersは軽量・高速ですが、WebAssemblyの動的生成は禁止されています。制約を回避するには「実行タイミングをずらす」という発想が有効です。
- **ビルド時 vs ランタイムのトレードオフ**: ビルド時に重い処理を済ませることで、ユーザーアクセス時（ランタイム）のパフォーマンスを最大化できます。
- **並列処理とシングルトンの重要性**: 重い初期化処理を伴うリソースを並列処理で使う場合、処理の開始前に一度だけ初期化を行うことでリソースの競合を防げます。

### パフォーマンス結果

~~~text
📊 ビルド時変換の結果:
- 最速: 1ms (welcome)
- 最長: 322ms (cloudflare-pages-deployment-challenge)
- 平均: 約30-40ms
- 合計: 21記事を数秒で変換完了
~~~

### 今後のベストプラクティス

- **サーバーレス環境の制約を事前確認する**: ライブラリを選定する際は、デプロイ先の実行環境（Cloudflare Workers, AWS Lambdaなど）との互換性を確認することが重要です。
- **ビルド時生成を積極的に活用する**: 静的サイトジェネレーション（SSG）の考え方を応用し、ビルド時に可能な処理はできる限り前倒しで実行することで、パフォーマンスと安定性が向上します。

## 🔗 関連リソース

- [Cloudflare Workers - WebAssembly制約](https://developers.cloudflare.com/workers/runtime-apis/webassembly/)
- [Shiki公式ドキュメント](https://shiki.style/)
- [Marked.js - マークダウンパーサー](https://marked.js.org/)
