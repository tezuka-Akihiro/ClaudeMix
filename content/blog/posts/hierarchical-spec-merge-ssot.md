---
slug: "hierarchical-spec-merge-ssot"
title: "「階層型スペック・マージ」によるSSOTの極致：疎結合とパフォーマンスの両立"
description: "3段階の階層型マージとESモジュール生成により、情報の整合性とエッジ環境でのパフォーマンスを両立するSSOT設計の決定版。"
author: "ClaudeMix Team"
publishedAt: "2025-11-20"
category: "ClaudeMix 考察"
tags: ["architecture", "refactoring", "performance", "TypeScript", "Vite"]
freeContentHeading: "課題と解決策"
---

## はじめに

### 仕様変更のたびに全方位を修正する、そんなことありませんか？

サイトのカテゴリを一つ追加しようとしただけで、UIのラベルを書き換え、バリデーションを修正し、さらにテストコードまで手を入れる。
しかし、これら情報の散在は、必ずどこかで「修正漏れ」を引き起こし、本番環境での不整合という致命的なバグを生みます。
場当たり的なハードコードで回避しても、それは将来の自分（またはAI）の足を引っ張る、保守不可能な「テキスト負債」の積み上げに過ぎません。

### この記事をお勧めしない人

- プロジェクトの設定値が複数のファイルに散らばっていても、全く問題ない人。
- クライアントサイドのバンドルサイズより、開発の単純さだけが大切だと考える人。
- 10年後も「死なない」プロダクトを作ることに、自分には関係ないと思う人。

もし一つでも当てはまらないなら、読み進める価値があるかもしれません。

### 実は危ない「情報のスラム化」

☠ 怖いことが起こる土壌として、仕様、実装、テストがバラバラに定義され、情報の整合性が個人の記憶に依存し始めます（リスクの兆候）。
☠ やがて、小さなラベル変更が「なぜか壊れたE2Eテスト」の調査という、本来不要なタスクを引き起こし、開発の勢いを削ぎ落とします（具体的なトリガー）。
☠ ついに、変更への恐怖がプロダクトの進化を止め、あなたのシステムは誰にも触れられない「情報のゴミ屋敷」と化してしまいます（最悪のシナリオ）。

### 階層型スペック・マージという明るい未来

✅ この記事を読めば、YAMLファイルを1行変えるだけで、全体が安全かつ瞬時に同期される「情報のSingle Source of Truth（SSOT）」という明るい未来があります。
✅ 具体的には、3段階の継承構造とビルド時の差分抽出により、疎結合な開発と厳格な一貫性を両立させる**設計図**を手に入れられます。
✅ この方法は、筆者が運営する本番環境のブログにおいて、Lighthouse 100点を維持しながら開発効率を劇的に向上させ、その実効性を実証済みです。
✅ この情報は、単なる設定ファイルの集約を超えた、AI時代の最強の「延命設計」に関する、**巷の情報では決して得られない**実践知です。

### このブログもそうでした

筆者も過去に同じ問題で悩み抜き、6年間の「システムの死の現場」との戦いの末に、この階層型スペック・マージという解決策にたどり着きました。
この記事で、AI時代のシステム設計において人間が担うべき「構造の正しさ」を、明日から試せるTipsと共に持ち帰れるように書きました。
深掘りしたい方は、詳細な実装方法を確認できます。

---

## 開発の進捗

- **Before**: サービス全体の設定（カテゴリ、セッション、UI文言）が各ドメインにハードコードされ、整合性の維持が困難だった。
- **Current**: 階層型スペック定義（Shared > Domain > Section）と差分抽出によるESモジュール生成が完了し、一貫した管理を実現。
- **Next**: 他のドメイン（アカウント管理、決済等）への完全適用を進め、全方位での情報のSingle Source of Truth（SSOT）を確立する。

## 具体的なタスク

- **Before**: 各ファイルに散在していたカテゴリ名やリンクパスを `spec.yaml` に集約。
- **Current**: ビルド時にYAMLを解析し、差分のみを抽出してESモジュールを生成する `generate-specs.js` を実装。
- **Next**: 生成されたスペックファイルを `deepMerge` してランタイムで再構築する共通ユーティリティを整備。

## 課題と解決策

サービスが成長するにつれ、単一の設定ファイルでは管理が限界を迎え、一方でファイル分割はドメイン間の結合やバンドルサイズの肥大化を招くというジレンマに直面しました。

### 工夫したこと

「3段階の階層型マージ」という戦略を採用しました。全社共通の `Shared`、ドメインごとの `Common`、そしてページ個別の `Section` という階層を持たせ、下位の定義が上位を「継承・上書き」する構造にしました。これにより、一箇所を変更すれば全体に波及する「SSOT」と、必要な情報だけを読み込む「疎結合」を両立させました。

### ぶつかった壁

単純にファイルをマージしてESモジュールを生成すると、上位階層の重複データが下位のファイルにも書き出され、クライアントサイドのバンドルサイズを無駄に増やしてしまうという問題がありました。特にエッジ環境（Cloudflare Workers）では、スクリプトサイズが実行速度や制限に直結するため、この冗長性は致命的でした。

### 解決方法

ビルド時に基底スペックと現在のスペックを比較し、変更（上書き）されたプロパティのみを抽出する「差分抽出ロジック（getDifference）」を開発しました。この抽出された「差分」だけをESモジュールとして書き出し、ランタイムで `deepMerge` することで、最小限の転送量で完全なスペックオブジェクトを再構築することに成功しました。

## コード抜粋

実際にスペックを生成する `generate-specs.js` のコアロジックと、ランタイムでの再構築手法を紹介します。

```javascript
// scripts/prebuild/generate-specs.js
// 基底（base）と対象（target）を比較し、差分のみを抽出する
function getDifference(target, base) {
  if (typeof target !== 'object' || target === null || Array.isArray(target)) {
    return target;
  }

  const diff = {};
  for (const key in target) {
    if (base && key in base) {
      if (typeof target[key] === 'object' && target[key] !== null && !Array.isArray(target[key])) {
        const subDiff = getDifference(target[key], base[key]);
        if (Object.keys(subDiff).length > 0) {
          diff[key] = subDiff;
        }
      } else if (target[key] !== base[key]) {
        diff[key] = target[key];
      }
    } else {
      diff[key] = target[key];
    }
  }
  return diff;
}
```

ランタイム側では、以下のようにマージして利用します。

```typescript
// app/generated/specs/blog/posts.ts
import { data as base } from './common';
import { deepMerge } from '~/lib/utils/deepMerge';

// 差分だけが埋め込まれ、実行時に完全なオブジェクトになる
export const data = deepMerge(base, {
  "posts_config": {
    "page_title": "Latest Update"
  }
}) as any;
```

### 今回の学びと感想

「情報の置き場所」を設計することは、コードを書くこと以上にプロダクトの寿命に直結すると痛感しました。SSOTは単なる「集約」ではなく、情報の「継承」と「抽出」のプロセスをシステム化することで、初めてAIエージェントとも協調可能な強靭な基盤になります。

同じような課題で悩んだ方はいませんか？
もっと良い解決方法があれば教えてください！
