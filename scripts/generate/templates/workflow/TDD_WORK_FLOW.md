# TDD作業手順書: {機能名}

## 1. 概要

**開発名**: {機能名} の実装
**目的**: {この開発の目的を記述}

## 2. 開発方針

- **Outside-In TDD (外側から内側へのTDD)**: ユーザーの振る舞いを定義するE2Eテスト（外側）から開発を始め、それをパスさせるために必要な各層の機能（内側）をユニットTDDで実装します。これは **受け入れテスト駆動開発 (ATDD)** の一種です。
- **段階的E2Eテスト戦略**:
    1. **E2Eファースト**: 最初に主要な成功シナリオ（Happy Path）のE2Eテストを1つだけ作成し、開発の最終ゴールを定義します。
    2. **Double-Loop TDD**: E2Eテスト（Outer Loop）をパスさせるために、各層（UI, Logic, Data-IO）でユニットテスト（Inner Loop）のTDDサイクルを回して実装を進めます。
    3. **E2E拡張**: 最初のE2Eテストが成功した後、エラーケースや境界値などの詳細なE2Eテストを追加し、品質を盤石にします。

---

## 3. 作業手順 (WBS)

### Phase 1: E2Eファースト (Happy Pathの定義) 🔴未着手

- **1. E2Eテストの準備**:
  - **`common`セクションの場合**: 画面レベルのE2Eテストファイル `tests/e2e/{{service}}/common.spec.ts` を**新規作成**します。
    - **依頼例**: `@GeneratorOperator "{{service}} サービスの画面レベルE2Eテストを作成して"`
  - **`common`セクション以外の場合**: E2Eテストファイル `tests/e2e/{{service}}/{{section}}.spec.ts` に、このセクションのHappy Pathを検証するテストを作成します。
  - **テスト基準**: `E2E_TEST_CRITERIA.md` の以下を参考に、開発のゴールを定義します。
    - **画面レベル**: ページが正常に表示され、主要なセクションが描画されること。
    - **セクションレベル**: 最も重要なユーザーアクションが成功するシナリオ。
- **2. テストの失敗を確認**: `npm run test:e2e` を実行し、実装がまだ存在しないため、このテストが失敗すること（RED）を確認します。
  - この失敗したテストが、Phase 2で実装すべき機能の明確なゴールとなります。

### Phase 2: CSS実装（Layer 2/3/4） 🔴未着手

**目的**: `uiux-spec.md` で設計した内容を、実際のCSSファイルとして実装します。

**実装対象**:

1. **Layer 2**: `app/styles/{{service}}/layer2-*.css`
2. **Layer 3**: `app/styles/{{service}}/layer3.ts`
3. **Layer 4**: `app/styles/{{service}}/layer4.ts`（必要な場合のみ）

**段階的更新の運用**:

- **初回セクション（commonセクション）**: 新規サービス実装時は、**必ずcommonセクションを最初に実施**します
  - `uiux-spec.md` で画面共通コンポーネント（ページコンテナ、ヘッダー、フッター等）のCSS設計を行います
  - このフェーズでCSS実装ファイル（layer2-*.css等）を新規作成し、サービス全体のCSS基盤を確立します
- **2回目以降のセクション**: 新規セクション開発時は、各セクションの `uiux-spec.md` で該当セクションのコンポーネント設計を行い、このフェーズで既存のCSS実装ファイルに追記します
- **共通化の検討**: 既存セクションに類似コンポーネントがある場合、必ず共通化を検討してください
- **整合性の確認**: 追加時は、既存実装との整合性（命名規則、トークン使用等）を確認してください

**手順**:

1. **Layer 2 実装**:
   - `uiux-spec.md` で定義したコンポーネントを元に `layer2-*.css` を実装
   - コンポーネントセレクタ (`.{component}-{variant?}`) で定義
   - すべての値は `var(--*)` でLayer 1トークンを参照

2. **Layer 3 実装**:
   - `uiux-spec.md` の「認定済み並列配置」セクションを元に `layer3.ts` を実装
   - Tailwind plugin形式（`addComponents`）でレイアウトを定義
   - gap のみ `var(--spacing-*)` を直接参照可能

3. **Layer 4 実装**（必要な場合のみ）:
   - `uiux-spec.md` で定義した例外的な構造を元に `layer4.ts` を実装
   - 例外的な構造のみを定義

4. **検証**:

   ```bash
   npm run lint:css-arch
   ```

   - 違反が検出された場合は `tests/lint/css-arch-layer-report.md` の内容に従って修正

5. **確認事項**:
   - ✅ Layer 2で色・サイズ・タイポグラフィが定義されている
   - ✅ Layer 3でフレックス・グリッドレイアウトのみが定義されている
   - ✅ margin が使用されていない（gap統一の原則）
   - ✅ `!important` が使用されていない
   - ✅ リント検証に合格している

### Phase 3: 層別TDD (ユニット/コンポーネント実装) 🔴未着手

#### 3.1. app/componentsの実装

- **1. UIコンポーネントの作成**:
  - **`common`セクションの場合**:
    - ページコンテナ（`app/routes/{{service}}.tsx`）と、共有コンポーネント（`Header`, `Footer`など）を生成します。
    - **依頼例**: `@GeneratorOperator "{{service}} サービスのページコンテナと共有コンポーネントを作成して"`
  - **`common`セクション以外の場合**:
    - 機能セクションのUIコンポーネント（例: `DesignFlowSection.tsx`）を生成します。
    - **依頼例**: `@GeneratorOperator "{{service}} サービスの {{section}} セクションに、{{name}} という名前のUIコンポーネントを作成して"`
    - **前提**: このコンポーネントを呼び出す親のページコンテナは、`common`セクションで実装済みです。
- **2. テスト実装 (RED)**: 生成されたテストファイルに、コンポーネントが正しくレンダリングされるかのテストを記述します。
- **3. 実装 (GREEN)**: コンポーネントを実装し、テストをパスさせます。
  - **スタイリング制約**:
    - ❌ **フロー制御クラスの直接使用禁止**: `flex`, `grid`, `gap` は直接使用せず、Layer 3で定義された構造クラスを使用
    - ❌ **個別スタイリングの禁止**: `p-4`, `w-1/2`, `text-blue-500` のようなユーティリティクラスを直接組み合わせるのではなく、Layer 2で定義されたコンポーネントクラス（例: `.btn-primary`）を使用
    - ✅ **責務の分離**: TSXファイルでは、Layer 3で定義されたレイアウト用クラスと、Layer 2で定義された見た目用クラスの組み合わせのみを許可
- **4. リファクタリング**: コードの可読性を向上させます。

#### 3.2. 🧠 純粋ロジック層の実装

- **1. ファイル生成**: `@GeneratorOperator` に依頼して、純粋ロジック層のファイルを生成します。
  - **依頼例**: `@GeneratorOperator "{{service}} サービスの {{section}} セクションに、{{logicName}} という名前のlibファイルを作成して"`
- **2. テスト実装 (RED)**: `{{logicName}}.test.ts` に、正常系・異常系・境界値のテストケースを記述します。
- **3. 実装 (GREEN)**: `{{logicName}}.ts` を実装し、テストをパスさせます。
- **4. リファクタリング**: ロジックをより効率的で読みやすい形に改善します。

#### 3.3. 🔌 副作用層の実装

- **1. ファイル生成**: `@GeneratorOperator` に依頼して、副作用層のファイルを生成します。
  - **依頼例**: `@GeneratorOperator "{{service}} サービスの {{section}} セクションに、{{ioName}} という名前のdata-ioファイルを作成して"`
- **2. テスト実装 (RED)**: `{{ioName}}.test.ts` に、外部依存をモック化した上で、正常系と異常系のテストを記述します。
- **3. 実装 (GREEN)**: `{{ioName}}.ts` を実装し、テストをパスさせます。
- **4. リファクタリング**: エラーハンドリングやリソース管理を改善します。

### Phase 4: E2E拡張と統合確認 🔴未着手

- **1. Happy Pathの成功確認**: `npm run test:e2e` を実行し、Phase 1で作成したHappy PathのE2Eテストが完全に成功すること（GREEN）を確認します。
- **2. 詳細E2Eテスト実装**: E2Eテストファイルに、エラーケース、境界値、他機能との連携など、より詳細なシナリオのテストケースを追記します。
  - **テスト基準**: `E2E_TEST_CRITERIA.md` の以下を参考に、品質を盤石にします。
    - **セクションレベル**: 主要アクションのエラーハンドリング。
    - **コンポーネントレベル**: バリデーション、インタラクション、アクセシビリティの検証。
- **3. E2Eテストのオールグリーンを確認**: `npm run test:e2e` を実行し、追加したものを含め、すべてのE2Eテストが成功することを確認します。
- **4. スタイリング規律確認**: `npm run lint:css-arch` を実行し、`globals.css` 内に配置プロパティ（width, height, margin, padding, display, flex, grid など）が含まれていないことを確認します。
  - **違反が検出された場合**: `tests/lint/css-arch-layer-report.md` の内容に従って修正してください。
  - **原則**: 「描き方（色・フォント）」はデザイントークン（CSS変数）、「配置（位置・サイズ・間隔）」はTailwindクラス
  - **詳細**: `docs/CSS_structure/STYLING_CHARTER.md`
- **5. 表示確認&承認**: `npm run dev` でアプリケーションを起動し、実際のブラウザで全ての機能が仕様通りに動作することを最終確認します。
- **6. (任意) モデルベーステストの検討**: 状態が複雑に変化するコンポーネントに対して、`E2E_TEST_CRITERIA.md` のモデルベーステスト(MCP)の導入を検討し、UIの堅牢性をさらに高めます。

---

## 4. 不具合発見時のフィードバックループ

開発中に予期せぬ不具合が発見された場合、それはテストの抜け漏れを意味します。以下の手順でテストスイートを強化し、同じ不具合の再発を恒久的に防ぎます。

1. **再現テストの作成 (E2E or ユニット)**: まず、発見された不具合を再現する**失敗するテスト**を記述します。これは多くの場合、E2Eテストか、特定のコンポーネントの統合テストになります。
2. **原因特定とユニットテストの強化**:
    - デバッグを行い、不具合の根本原因となっている純粋ロジック（lib）やコンポーネントを特定します。
    - その原因を最小単位で再現する**失敗するユニットテスト**を追加します。
3. **実装の修正 (GREEN)**: 追加したユニットテストがパスするように、原因となったコードを修正します。
4. **再現テストの成功確認 (GREEN)**: 最初に作成した再現テスト（E2E/統合テスト）を実行し、こちらもパスすることを確認します。
5. **知見の共有**: この経験を「学んだこと・気づき」セクションに記録し、チームの知識として蓄積します。

---

## 5. 進捗ログ

| 日付 | 作業内容 | 完了項目 | 次回予定 |
|------|----------|----------|----------|

## 6. 学んだこと・気づき

- {TDDプロセスや技術的な発見、設計に関する気づき、発見した不具合の原因と対策などを記録します}

## 7. さらなる改善提案

- {開発中に気づいた、今回のスコープ外の改善点や次のタスク候補を記録します}
