#!/usr/bin/env node

/**
 * ãƒ—ãƒªãƒ“ãƒ«ãƒ‰ã‚¹ã‚¯ãƒªãƒ—ãƒˆ: ãƒ©ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ãƒãƒ³ãƒ‰ãƒ«ç”Ÿæˆ
 *
 * ã“ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ã€ãƒ“ãƒ«ãƒ‰æ™‚ã«å®Ÿè¡Œã•ã‚Œã€ãƒ©ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒšãƒ¼ã‚¸ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’
 * TypeScriptãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ãƒãƒ³ãƒ‰ãƒ«ã—ã¾ã™ã€‚Cloudflare Workersã§ã¯
 * ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚¢ã‚¯ã‚»ã‚¹ãŒã§ããªã„ãŸã‚ã€ãƒ“ãƒ«ãƒ‰æ™‚ã«ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’
 * ãƒãƒ³ãƒ‰ãƒ«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
 */

import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import yaml from 'js-yaml';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.join(__dirname, '../..');

/**
 * ãƒ©ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ãƒãƒ³ãƒ‰ãƒ«ã™ã‚‹
 */
async function generateLandingContent() {
  try {
    console.log('ğŸš€ Starting landing content generation...');

    const landingDir = path.join(rootDir, 'content/blog/landing');
    const outputPath = path.join(rootDir, 'app/generated/landing-content.ts');

    // 1. content/blog/landingé…ä¸‹ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’èª­ã¿è¾¼ã‚€
    const contents = {};
    const mangaAssets = {};

    let targets = [];
    try {
      targets = await fs.readdir(landingDir);
    } catch {
      console.log('   âš ï¸ Landing directory does not exist, creating empty bundle');
      targets = [];
    }

    // public/images/blog/landing ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆ
    const publicLandingDir = path.join(rootDir, 'public/images/blog/landing');
    await fs.mkdir(publicLandingDir, { recursive: true });

    for (const target of targets) {
      const targetPath = path.join(landingDir, target);
      const stat = await fs.stat(targetPath);

      if (!stat.isDirectory()) continue;

      // content.yaml ã®èª­ã¿è¾¼ã¿
      const contentYamlPath = path.join(targetPath, 'content.yaml');
      try {
        const yamlString = await fs.readFile(contentYamlPath, 'utf-8');
        const parsedContent = yaml.load(yamlString);

        // snake_case ã‹ã‚‰ camelCase ã«å¤‰æ›
        contents[target] = {
          targetSlug: parsedContent.target_slug,
          catchCopy: parsedContent.catch_copy,
          description: parsedContent.description,
          ctaButtonText: parsedContent.cta_button_text,
          ctaLinks: parsedContent.cta_links.map(link => ({
            label: link.label,
            url: link.url,
            aria_label: link.aria_label,
          })),
          mangaPanelCount: parsedContent.manga_panel_count,
        };
        console.log(`   âœ… Loaded content: ${target}`);
      } catch (error) {
        console.error(`   âŒ Failed to load content ${contentYamlPath}:`, error.message);
        continue;
      }

      // manga/ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ç”»åƒä¸€è¦§ã‚’å–å¾—
      const mangaDir = path.join(targetPath, 'manga');
      try {
        const files = await fs.readdir(mangaDir);
        // AVIFã«çµ±ä¸€ã™ã‚‹ãŸã‚ã€.avifã®ã¿ã‚’å¯¾è±¡ã¨ã™ã‚‹
        const imageExtensions = ['.avif'];
        const imageFiles = [];

        // public/images/blog/landing/${target}/manga ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆ
        const publicTargetMangaDir = path.join(publicLandingDir, target, 'manga');
        await fs.mkdir(publicTargetMangaDir, { recursive: true });

        for (const file of files) {
          const ext = file.toLowerCase().slice(file.lastIndexOf('.'));
          if (!imageExtensions.includes(ext)) continue;

          const filePath = path.join(mangaDir, file);
          const fileStat = await fs.stat(filePath);
          if (fileStat.isFile()) {
            imageFiles.push(file);

            // ç”»åƒã‚’publicãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ã‚³ãƒ”ãƒ¼
            const destPath = path.join(publicTargetMangaDir, file);
            await fs.copyFile(filePath, destPath);
          }
        }

        // ãƒ•ã‚¡ã‚¤ãƒ«åã§ã‚½ãƒ¼ãƒˆ
        const sortedFiles = imageFiles.sort((a, b) => a.localeCompare(b));

        // MangaAssetå‹ã«å¤‰æ›ï¼ˆpublicã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªãƒ‘ã‚¹ã«å¤‰æ›´ï¼‰
        mangaAssets[target] = sortedFiles.map((file, index) => ({
          fileName: file,
          path: `/images/blog/landing/${target}/manga/${file}`,
          order: index + 1,
        }));
        console.log(`   âœ… Loaded ${sortedFiles.length} manga assets for: ${target}`);
        console.log(`   ğŸ“ Copied ${sortedFiles.length} images to public directory`);
      } catch {
        // manga ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ç©ºé…åˆ—
        mangaAssets[target] = [];
        console.log(`   âš ï¸ No manga directory for: ${target}`);
      }
    }

    console.log(`ğŸ“ Found ${Object.keys(contents).length} landing targets`);

    // 2. TypeScriptãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆ
    const tsContent = `// Auto-generated by scripts/prebuild/generate-landing-content.js
// Do not edit manually - this file is regenerated on every build

/**
 * ãƒ©ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒšãƒ¼ã‚¸ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ï¼ˆãƒ“ãƒ«ãƒ‰æ™‚ç”Ÿæˆï¼‰
 *
 * ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€ãƒ“ãƒ«ãƒ‰æ™‚ã«content/blog/landing/é…ä¸‹ã®YAMLãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰
 * è‡ªå‹•ç”Ÿæˆã•ã‚Œã¾ã™ã€‚Cloudflare Workersã§ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚¢ã‚¯ã‚»ã‚¹ãŒã§ããªã„ãŸã‚ã€
 * ãƒ“ãƒ«ãƒ‰æ™‚ã«ã™ã¹ã¦ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ãƒãƒ³ãƒ‰ãƒ«ã—ã¦ã„ã¾ã™ã€‚
 */

import type { LandingContent, MangaAsset } from '~/specs/blog/types';

/**
 * ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåˆ¥ã‚³ãƒ³ãƒ†ãƒ³ãƒ„
 */
const contents: Record<string, LandingContent> = ${JSON.stringify(contents, null, 2)};

/**
 * ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåˆ¥æ¼«ç”»ã‚¢ã‚»ãƒƒãƒˆ
 */
const mangaAssets: Record<string, MangaAsset[]> = ${JSON.stringify(mangaAssets, null, 2)};

/**
 * ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåˆ¥ã®ãƒ©ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’å–å¾—
 * @param target ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚¹ãƒ©ãƒƒã‚°ï¼ˆä¾‹: 'engineer'ï¼‰
 * @returns ãƒ©ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚³ãƒ³ãƒ†ãƒ³ãƒ„
 * @throws ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒå­˜åœ¨ã—ãªã„å ´åˆ
 */
export function getLandingContentBundled(target: string): LandingContent {
  if (!contents[target]) {
    throw new Error(\`Landing content not found for target: \${target}\`);
  }
  return contents[target];
}

/**
 * ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåˆ¥ã®æ¼«ç”»ã‚¢ã‚»ãƒƒãƒˆã‚’å–å¾—
 * @param target ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚¹ãƒ©ãƒƒã‚°ï¼ˆä¾‹: 'engineer'ï¼‰
 * @returns æ¼«ç”»ã‚¢ã‚»ãƒƒãƒˆé…åˆ—
 */
export function getMangaAssetsBundled(target: string): MangaAsset[] {
  return mangaAssets[target] || [];
}

/**
 * åˆ©ç”¨å¯èƒ½ãªã‚¿ãƒ¼ã‚²ãƒƒãƒˆä¸€è¦§ã‚’å–å¾—
 */
export function getAvailableTargets(): string[] {
  return Object.keys(contents);
}
`;

    // 3. å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆ
    const outputDir = path.dirname(outputPath);
    await fs.mkdir(outputDir, { recursive: true });

    // 4. ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›¸ãå‡ºã—
    await fs.writeFile(outputPath, tsContent, 'utf-8');
    console.log(`âœ… Generated ${outputPath}`);

    console.log('\nâœ¨ Landing content generation completed successfully!');
    console.log(`\nğŸ“Š Summary:`);
    console.log(`   - Targets: ${Object.keys(contents).length}`);
    for (const target of Object.keys(contents)) {
      console.log(`     - ${target}: ${mangaAssets[target]?.length || 0} manga panels`);
    }
  } catch (error) {
    console.error('âŒ Failed to generate landing content:', error);
    process.exit(1);
  }
}

// ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’å®Ÿè¡Œ
generateLandingContent();
