#!/usr/bin/env node

/**
 * ãƒ—ãƒªãƒ“ãƒ«ãƒ‰ã‚¹ã‚¯ãƒªãƒ—ãƒˆ: ãƒ–ãƒ­ã‚°è¨˜äº‹ã®ãƒãƒ³ãƒ‰ãƒ«ç”Ÿæˆ
 *
 * ã“ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ã€ãƒ“ãƒ«ãƒ‰æ™‚ã«å®Ÿè¡Œã•ã‚Œã€Markdownãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰
 * TypeScriptãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç”Ÿæˆã—ã¾ã™ã€‚Cloudflare Workersã§ã¯
 * ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚¢ã‚¯ã‚»ã‚¹ãŒã§ããªã„ãŸã‚ã€ãƒ“ãƒ«ãƒ‰æ™‚ã«ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’
 * ãƒãƒ³ãƒ‰ãƒ«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
 */

import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import matter from 'gray-matter';
import yaml from 'js-yaml';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.join(__dirname, '../..');

/**
 * ãƒ–ãƒ­ã‚°è¨˜äº‹ã‚’ç”Ÿæˆã™ã‚‹
 */
async function generateBlogPosts() {
  try {
    console.log('ðŸš€ Starting blog posts generation...');

    // 1. Markdownãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€
    const postsDir = path.join(rootDir, 'content/blog/posts');
    const files = await fs.readdir(postsDir);
    const markdownFiles = files.filter(file => file.endsWith('.md'));

    console.log(`ðŸ“ Found ${markdownFiles.length} markdown files`);

    // 2. å„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è§£æž
    const posts = await Promise.all(
      markdownFiles.map(async (file) => {
        const slug = file.replace(/\.md$/, '');
        const filePath = path.join(postsDir, file);
        const fileContent = await fs.readFile(filePath, 'utf-8');

        // gray-matterã§ãƒ•ãƒ­ãƒ³ãƒˆãƒžã‚¿ãƒ¼ã‚’è§£æž
        const { data, content } = matter(fileContent);

        // publishedAtã‚’æ­£è¦åŒ–
        const publishedAt = data.publishedAt instanceof Date
          ? data.publishedAt.toISOString().split('T')[0]
          : typeof data.publishedAt === 'string'
          ? data.publishedAt
          : String(data.publishedAt);

        // å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®æ¤œè¨¼
        if (!data.title || typeof data.title !== 'string') {
          throw new Error(`Invalid frontmatter in ${file}: missing or invalid 'title'`);
        }

        if (!publishedAt) {
          throw new Error(`Invalid frontmatter in ${file}: missing 'publishedAt'`);
        }

        // å¤–éƒ¨ãƒ•ã‚¡ã‚¤ãƒ«å‚ç…§æ©Ÿèƒ½: sourceãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒã‚ã‚‹å ´åˆã€å¤–éƒ¨ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€
        // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ãƒ“ãƒ«ãƒ‰ã‚’å¤±æ•—ã•ã›ã‚‹ï¼ˆãƒ“ãƒ«ãƒ‰æ™‚å“è³ªä¿è¨¼ï¼‰
        let finalContent = content;
        if (data.source && typeof data.source === 'string') {
          const externalFilePath = path.join(rootDir, data.source);
          try {
            const externalContent = await fs.readFile(externalFilePath, 'utf-8');
            finalContent = externalContent;
            console.log(`   âœ… Loaded external file: ${data.source}`);
          } catch (error) {
            throw new Error(`Failed to load external file "${data.source}" for post "${slug}": ${error.message}`);
          }
        }

        return {
          slug,
          frontmatter: {
            title: data.title,
            publishedAt,
            summary: data.summary || '',
            author: data.author || 'Unknown',
            tags: Array.isArray(data.tags) ? data.tags : [],
            category: data.category || '',
            source: data.source || null,
            description: data.description || undefined,
            testOnly: data.testOnly === true,
          },
          content: finalContent,
        };
      })
    );

    console.log(`âœ… Parsed ${posts.length} posts`);

    // æœ¬ç•ªç’°å¢ƒã§ã¯ãƒ†ã‚¹ãƒˆå°‚ç”¨è¨˜äº‹ã‚’é™¤å¤–
    const isProduction = process.env.NODE_ENV === 'production';
    const filteredPosts = isProduction
      ? posts.filter(post => !post.frontmatter.testOnly)
      : posts;

    if (isProduction && filteredPosts.length < posts.length) {
      console.log(`ðŸ”’ Excluded ${posts.length - filteredPosts.length} test-only posts in production`);
    }

    console.log(`âœ… Final post count: ${filteredPosts.length}`);

    // 3. ã‚«ãƒ†ã‚´ãƒªå®šç¾©ã‚’èª­ã¿è¾¼ã‚€
    const specPath = path.join(rootDir, 'develop/blog/posts/spec.yaml');
    const specContent = await fs.readFile(specPath, 'utf-8');
    const spec = yaml.load(specContent);

    if (!spec.categories || !Array.isArray(spec.categories)) {
      throw new Error('Invalid spec.yaml: missing or invalid categories');
    }

    const categories = spec.categories.map((cat, index) => {
      if (typeof cat.id !== 'number' || typeof cat.name !== 'string' || typeof cat.emoji !== 'string') {
        throw new Error(`Invalid category at index ${index}: must have id (number), name (string), and emoji (string)`);
      }
      return {
        id: cat.id,
        name: cat.name,
        emoji: cat.emoji,
      };
    });

    console.log(`âœ… Loaded ${categories.length} categories`);

    // 4. TypeScriptãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ç”Ÿæˆ
    const output = `// Auto-generated by scripts/prebuild/generate-blog-posts.js
// Do not edit manually - this file is regenerated on every build

/**
 * ãƒ–ãƒ­ã‚°è¨˜äº‹ãƒ‡ãƒ¼ã‚¿ï¼ˆãƒ“ãƒ«ãƒ‰æ™‚ç”Ÿæˆï¼‰
 *
 * ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€ãƒ“ãƒ«ãƒ‰æ™‚ã«Markdownãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰è‡ªå‹•ç”Ÿæˆã•ã‚Œã¾ã™ã€‚
 * Cloudflare Workersã§ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚¢ã‚¯ã‚»ã‚¹ãŒã§ããªã„ãŸã‚ã€
 * ãƒ“ãƒ«ãƒ‰æ™‚ã«ã™ã¹ã¦ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ãƒãƒ³ãƒ‰ãƒ«ã—ã¦ã„ã¾ã™ã€‚
 */

export interface BlogPostFrontmatter {
  title: string;
  publishedAt: string; // ISO format "YYYY-MM-DD"
  summary: string;
  author: string;
  tags: string[];
  category: string;
  source: string | null; // å¤–éƒ¨ãƒžãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®å‚ç…§
  description?: string; // ã‚ªãƒ—ã‚·ãƒ§ãƒ³: è¨˜äº‹ã®èª¬æ˜Ž
  testOnly: boolean; // ãƒ†ã‚¹ãƒˆå°‚ç”¨è¨˜äº‹ãƒ•ãƒ©ã‚°ï¼ˆæœ¬ç•ªç’°å¢ƒã§ã¯é™¤å¤–ï¼‰
}

export interface BlogPost {
  slug: string;
  frontmatter: BlogPostFrontmatter;
  content: string; // ãƒžãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³å½¢å¼
}

export interface Category {
  id: number;
  name: string;
  emoji: string;
}

// ==========================================
// ã‚«ãƒ†ã‚´ãƒªãƒ‡ãƒ¼ã‚¿
// ==========================================

export const categories: Category[] = ${JSON.stringify(categories, null, 2)};

// ==========================================
// ãƒ–ãƒ­ã‚°è¨˜äº‹ãƒ‡ãƒ¼ã‚¿
// ==========================================

export const posts: BlogPost[] = ${JSON.stringify(filteredPosts, null, 2)};

// ==========================================
// ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
// ==========================================

/**
 * slugã‹ã‚‰è¨˜äº‹ã‚’å–å¾—ã™ã‚‹
 */
export function getPostBySlug(slug: string): BlogPost | undefined {
  return posts.find(post => post.slug === slug);
}

/**
 * ã™ã¹ã¦ã®è¨˜äº‹ã‚’å–å¾—ã™ã‚‹ï¼ˆæŠ•ç¨¿æ—¥é™é †ï¼‰
 */
export function getAllPosts(): BlogPost[] {
  return posts.sort((a, b) =>
    new Date(b.frontmatter.publishedAt).getTime() -
    new Date(a.frontmatter.publishedAt).getTime()
  );
}

/**
 * ã‚«ãƒ†ã‚´ãƒªåã‹ã‚‰çµµæ–‡å­—ã‚’å–å¾—ã™ã‚‹
 */
export function getCategoryEmoji(categoryName: string): string {
  const category = categories.find(cat => cat.name === categoryName);
  return category?.emoji || 'ðŸ“„';
}

/**
 * ã‚«ãƒ†ã‚´ãƒªIDã‹ã‚‰ã‚«ãƒ†ã‚´ãƒªã‚’å–å¾—ã™ã‚‹
 */
export function getCategoryById(id: number): Category | undefined {
  return categories.find(cat => cat.id === id);
}

/**
 * ã‚«ãƒ†ã‚´ãƒªåã‹ã‚‰ã‚«ãƒ†ã‚´ãƒªã‚’å–å¾—ã™ã‚‹
 */
export function getCategoryByName(name: string): Category | undefined {
  return categories.find(cat => cat.name === name);
}
`;

    // 5. å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆ
    const outputDir = path.join(rootDir, 'app/generated');
    await fs.mkdir(outputDir, { recursive: true });

    // 6. ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›¸ãè¾¼ã‚€
    const outputPath = path.join(outputDir, 'blog-posts.ts');
    await fs.writeFile(outputPath, output, 'utf-8');

    console.log(`âœ… Generated ${outputPath}`);
    console.log(`ðŸ“¦ Bundle contains ${filteredPosts.length} posts and ${categories.length} categories`);
    console.log('âœ¨ Blog posts generation completed successfully!');

    return { posts: filteredPosts.length, categories: categories.length };
  } catch (error) {
    console.error('âŒ Error generating blog posts:', error);
    throw error;
  }
}

// ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’å®Ÿè¡Œ
generateBlogPosts()
  .then(({ posts, categories }) => {
    console.log(`\nðŸ“Š Summary:`);
    console.log(`   - Posts: ${posts}`);
    console.log(`   - Categories: ${categories}`);
    process.exit(0);
  })
  .catch(error => {
    console.error('\nðŸ’¥ Fatal error:', error.message);
    process.exit(1);
  });
