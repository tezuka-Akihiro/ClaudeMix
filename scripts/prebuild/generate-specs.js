#!/usr/bin/env node

/**
 * ãƒ—ãƒªãƒ“ãƒ«ãƒ‰ã‚¹ã‚¯ãƒªãƒ—ãƒˆ: ç–Žçµåˆãƒ»3æ®µéšŽãƒžãƒ¼ã‚¸ãƒ»é‡è¤‡æŽ’é™¤ã‚¹ãƒšãƒƒã‚¯ç”Ÿæˆ
 */

import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import yaml from 'js-yaml';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.join(__dirname, '../..');

const SPECS_DIR = path.join(rootDir, 'app/specs');
const OUTPUT_BASE = path.join(rootDir, 'app/generated/specs');

/**
 * ãƒ‡ã‚£ãƒ¼ãƒ—ã‚³ãƒ”ãƒ¼
 */
function clone(obj) {
  return JSON.parse(JSON.stringify(obj));
}

/**
 * ãƒ‡ã‚£ãƒ¼ãƒ—ãƒžãƒ¼ã‚¸
 */
function deepMerge(target, source) {
  const result = clone(target);
  for (const key in source) {
    if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
      if (!result[key]) result[key] = {};
      result[key] = deepMerge(result[key], source[key]);
    } else {
      result[key] = source[key];
    }
  }
  return result;
}

/**
 * å·®åˆ†æŠ½å‡º (sourceã‹ã‚‰targetã«å«ã¾ã‚Œã‚‹å…±é€šéƒ¨åˆ†ã‚’å¼•ã„ãŸã‚‚ã®)
 */
function getDifference(target, base) {
  if (typeof target !== 'object' || target === null || Array.isArray(target)) {
    return target;
  }

  const diff = {};
  let hasDiff = false;

  for (const key in target) {
    if (base && key in base) {
      if (typeof target[key] === 'object' && target[key] !== null && !Array.isArray(target[key])) {
        const subDiff = getDifference(target[key], base[key]);
        if (Object.keys(subDiff).length > 0) {
          diff[key] = subDiff;
          hasDiff = true;
        }
      } else if (target[key] !== base[key]) {
        diff[key] = target[key];
        hasDiff = true;
      }
    } else {
      diff[key] = target[key];
      hasDiff = true;
    }
  }
  return diff;
}

/**
 * ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ç”Ÿæˆ
 */
async function generateModule({ subPath, data, baseImport = null, baseData = null }) {
  const outputPath = path.join(OUTPUT_BASE, `${subPath}.ts`);
  const outputDir = path.dirname(outputPath);
  await fs.mkdir(outputDir, { recursive: true });

  let content = `// Auto-generated by generate-specs.js
`;

  if (baseImport) {
    const diff = getDifference(data, baseData);
    content += `import { data as base } from '${baseImport}';
import { deepMerge } from '~/lib/utils/deepMerge';

export const data = deepMerge(base, ${JSON.stringify(diff, null, 2)}) as any;
export default data;
`;
  } else {
    content += `export const data = ${JSON.stringify(data, null, 2)} as any;
export default data;
`;
  }

  await fs.writeFile(outputPath, content, 'utf-8');
  console.log(`   âœ… Generated: ${subPath}.ts`);
}

async function main() {
  console.log('ðŸš€ Starting Advanced Specs Generation...');

  // å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®åˆæœŸåŒ–
  await fs.rm(OUTPUT_BASE, { recursive: true, force: true });
  await fs.mkdir(OUTPUT_BASE, { recursive: true });

  const allSpecs = []; // { featurePath, subPath }

  // 1. åŸºåº•ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ãƒ­ãƒ¼ãƒ‰ (ui-patterns)
  const uiPatternsPath = path.join(SPECS_DIR, 'shared/ui-patterns-spec.yaml');
  const uiPatterns = yaml.load(await fs.readFile(uiPatternsPath, 'utf-8'));
  delete uiPatterns._templates;

  // 2. Sharedé ˜åŸŸã®ç”Ÿæˆ
  const sharedFiles = (await fs.readdir(path.join(SPECS_DIR, 'shared')))
    .filter(f => f.endsWith('-spec.yaml'));

  for (const file of sharedFiles) {
    const name = file.replace('-spec.yaml', '');
    const raw = yaml.load(await fs.readFile(path.join(SPECS_DIR, 'shared', file), 'utf-8'));
    await generateModule({ subPath: `shared/${name}`, data: raw });
    allSpecs.push({ featurePath: `shared/${name}`, subPath: `shared/${name}` });
  }

  // 3. ã‚µãƒ¼ãƒ“ã‚¹/ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ç”Ÿæˆ
  const services = (await fs.readdir(SPECS_DIR)).filter(s => s !== 'shared' && !s.includes('.'));

  for (const service of services) {
    const serviceDir = path.join(SPECS_DIR, service);

    // Domain Commonã®å‡¦ç†
    const commonFile = 'common-spec.yaml';
    const commonRaw = yaml.load(await fs.readFile(path.join(serviceDir, commonFile), 'utf-8'));
    const commonMerged = deepMerge(uiPatterns, commonRaw);

    await generateModule({
      subPath: `${service}/common`,
      data: commonMerged,
      baseImport: '../shared/ui-patterns',
      baseData: uiPatterns
    });
    allSpecs.push({ featurePath: `${service}/common`, subPath: `${service}/common` });

    // å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®å‡¦ç†
    const files = (await fs.readdir(serviceDir)).filter(f => f.endsWith('-spec.yaml') && f !== 'common-spec.yaml');

    for (const file of files) {
      const sectionName = file.replace('-spec.yaml', '');
      const sectionRaw = yaml.load(await fs.readFile(path.join(serviceDir, file), 'utf-8'));
      const sectionMerged = deepMerge(commonMerged, sectionRaw);

      await generateModule({
        subPath: `${service}/${sectionName}`,
        data: sectionMerged,
        baseImport: './common',
        baseData: commonMerged
      });
      allSpecs.push({ featurePath: `${service}/${sectionName}`, subPath: `${service}/${sectionName}` });
    }
  }

  // 4. Indexã®ç”Ÿæˆ (Syncãƒ­ãƒ¼ãƒ‰ç”¨)
  const indexContent = `// Auto-generated by generate-specs.js
${allSpecs.map(s => `import { data as ${s.subPath.replace(/\//g, '_').replace(/-/g, '_')} } from './${s.subPath}';`).join('\n')}

const specMap: Record<string, any> = {
${allSpecs.map(s => `  '${s.featurePath}': ${s.subPath.replace(/\//g, '_').replace(/-/g, '_')}`).join(',\n')}
};

export function getSpec<T>(featurePath: string): T {
  const spec = specMap[featurePath];
  if (!spec) {
    throw new Error(\`Spec not found: \${featurePath}\`);
  }
  return spec as T;
}

export function getSharedSpec<T>(specName: string): T {
  try {
    return getSpec<T>(\`shared/\${specName}\`);
  } catch (e) {
    throw new Error(\`Shared spec not found: \${specName}\`);
  }
}
`;
  await fs.writeFile(path.join(OUTPUT_BASE, 'index.ts'), indexContent, 'utf-8');
  console.log(`   âœ… Generated: index.ts`);

  console.log('\nâœ¨ Advanced Specs Generation Completed!');
}

main().catch(err => {
  console.error(err);
  process.exit(1);
});
