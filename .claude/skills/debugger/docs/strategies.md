# デバッグ戦略

レイヤー別のデバッグアプローチとよくある問題のパターン。

## レイヤー別デバッグアプローチ

### lib層のデバッグ

#### 焦点

純粋関数のロジック

#### 推奨ツール

- ユニットテストの詳細化
- 入力値のバリデーション確認
- 戻り値の型チェック
- エッジケースの検証

#### よくある問題

| 問題 | 症状 | 解決方法 |
| :--- | :--- | :--- |
| **境界値の処理ミス** | NaN、Infinity、エッジケースでの失敗 | ガード節追加、境界値テスト |
| **型の暗黙的変換** | 予期しない型変換 | 明示的な型変換、厳密な型定義 |
| **数値計算の精度問題** | 小数点計算の誤差 | 整数演算への変換、精度管理 |
| **配列/オブジェクトの不変性違反** | 意図しない副作用 | イミュータブルな操作、spread演算子 |

#### デバッグ手順

```text
1. ユニットテストで再現
2. 入力値の境界値を確認
3. 型定義の厳密性を確認
4. 副作用が混入していないか確認
5. エッジケースのテストを追加
```

---

### data-io層のデバッグ

#### 焦点

副作用と外部連携

#### 推奨ツール

- ネットワークリクエストのログ
- エラーハンドリングの検証
- モックの正確性確認
- リトライロジックの検証

#### よくある問題

| 問題 | 症状 | 解決方法 |
| :--- | :--- | :--- |
| **非同期処理のタイミング問題** | Race condition、タイミング依存のバグ | Promise.all、await の適切な使用 |
| **エラーハンドリング不足** | 未処理のエラー、クラッシュ | try-catch、エラーログ |
| **タイムアウト処理の欠如** | 長時間待機、ハング | AbortController、タイムアウト設定 |
| **レスポンス型の不一致** | 型エラー、null参照 | スキーマバリデーション（Zod等） |

#### デバッグ手順

```text
1. ネットワークタブでリクエスト/レスポンスを確認
2. エラーハンドリングがあるか確認
3. モックが正確か確認
4. 非同期処理の順序を確認
5. タイムアウト処理を追加
```

---

### ui層のデバッグ

#### 焦点

レンダリングとデータフロー

#### 推奨ツール

- React DevTools
- loader/action のログ確認
- 再レンダリングの追跡
- Playwright debugger

#### よくある問題

| 問題 | 症状 | 解決方法 |
| :--- | :--- | :--- |
| **状態管理の不整合** | UIの表示が期待と異なる | loader/actionへの移行、状態の簡素化 |
| **loader/action の実行順序** | データ取得のタイミング問題 | loader依存関係の見直し |
| **コンポーネントのライフサイクル** | マウント/アンマウント時のバグ | useEffect の依存配列確認 |
| **イベントハンドラーのバインディング** | イベントが発火しない | Form コンポーネントの使用、action活用 |

#### デバッグ手順

```text
1. React DevToolsでコンポーネントツリーを確認
2. loader/actionのログを確認
3. 再レンダリングの原因を追跡
4. Playwrightデバッガーで挙動を確認
5. Remixアーキテクチャに沿っているか確認
```

---

## エラータイプ別の戦略

### runtime-error（実行時エラー）

| 原因 | デバッグアプローチ |
| :--- | :--- |
| **null/undefined参照** | 型定義の厳密化、Optional Chaining |
| **型エラー** | TypeScript strict モード有効化 |
| **配列範囲外アクセス** | 境界値チェック、配列長確認 |

### test-failure（テスト失敗）

| 原因 | デバッグアプローチ |
| :--- | :--- |
| **テストケースが不正確** | 期待値の見直し、テストの修正 |
| **モックが不正確** | モックの実装確認、実際のAPIと比較 |
| **実装とテストの不整合** | TDDフローの見直し |

### type-error（TypeScriptエラー）

| 原因 | デバッグアプローチ |
| :--- | :--- |
| **型定義が不正確** | 型定義の見直し、インターフェース整備 |
| **any型の使用** | 具体的な型への置き換え |
| **型推論の失敗** | 明示的な型注釈 |

### build-error（ビルドエラー）

| 原因 | デバッグアプローチ |
| :--- | :--- |
| **依存関係エラー** | package.json確認、再インストール |
| **import/exportエラー** | パス確認、named/default import の確認 |
| **構文エラー** | リントツール使用、コード確認 |

### logic-error（ロジックエラー）

| 原因 | デバッグアプローチ |
| :--- | :--- |
| **アルゴリズムの誤り** | ステップバイステップで検証 |
| **エッジケース未考慮** | 境界値テスト追加 |
| **条件分岐の誤り** | 真理値表作成、全パターン検証 |

### integration-error（統合エラー）

| 原因 | デバッグアプローチ |
| :--- | :--- |
| **API仕様の誤解** | APIドキュメント確認、実際のレスポンス検証 |
| **データ形式の不一致** | スキーマバリデーション追加 |
| **認証エラー** | トークン確認、権限確認 |

### performance-issue（パフォーマンス問題）

| 原因 | デバッグアプローチ |
| :--- | :--- |
| **不要な再レンダリング** | React.memo、useMemo 使用 |
| **データ量が多すぎる** | ページネーション、仮想スクロール |
| **非効率なアルゴリズム** | 計算量削減、キャッシュ活用 |

---

## デバッグの原則

### 1. 再現性の確保

**目標**: 毎回同じ手順でエラーを再現できること

- 再現手順を明確化
- 環境要因を排除
- テストで再現

### 2. 分離と特定

**目標**: 問題箇所を最小限に絞り込むこと

- バイナリサーチ（半分ずつコメントアウト）
- console.log による追跡
- デバッガーのブレークポイント

### 3. 仮説検証

**目標**: 根本原因を論理的に特定すること

- 仮説を立てる
- テストで検証
- 結果を評価

### 4. 修正と検証

**目標**: 修正が正しいことを確認すること

- テストで検証
- エッジケースを確認
- 他への影響を確認

---

## よくあるアンチパターン

### ❌ ランダムな変更

**問題**: 何が問題かわからないまま、とりあえず変更してみる

**正しいアプローチ**: まず根本原因を特定してから修正

### ❌ 対症療法

**問題**: 現象だけを抑えて、根本原因を放置

**正しいアプローチ**: 5 Whys法で根本原因を追求

### ❌ 過度な複雑化

**問題**: シンプルな問題に複雑な解決策を適用

**正しいアプローチ**: 最もシンプルな修正を選択

### ❌ テスト不足

**問題**: 修正後にテストを実行しない

**正しいアプローチ**: 修正とテストはセット

---

## 参照

- `docs/tools.md` - デバッグツールの詳細
- `prompts/01-diagnose.md` - エラー診断の手順
- `prompts/02-analyze.md` - 根本原因分析の手順
- `prompts/03-fix.md` - 修正案生成の手順
